#!/usr/bin/env python

import os, sys
import boto3
import readline
from argparse import ArgumentParser
import subprocess
import itertools

ec2 = boto3.resource('ec2')
as_client = boto3.client('autoscaling')
elb_client = boto3.client('elbv2')
s3 = boto3.resource('s3')
s3_client = boto3.client('s3')


def target_group_arn_for(args):
    if args['env'] == 'prod':
        return 'arn:aws:elasticloadbalancing:us-east-1:052730242331:targetgroup/GccExplorerNodes/84e7c7626fd50397'
    else:
        return 'arn:aws:elasticloadbalancing:us-east-1:052730242331:targetgroup/Beta/07d45244520b84c4'


def run_remote(instance, command):
    os.system(
        'ssh -o UserKnownHostsFile=/dev/null -o StrictHostKeyChecking=no -o LogLevel=ERROR ubuntu@{} -- {}'.format(
            instance.instance.public_ip_address, " ".join(command)))


def exec_remote(instance, command):
    return subprocess.check_output(
        ['ssh', '-o', 'UserKnownHostsFile=/dev/null', '-o', 'StrictHostKeyChecking=no', '-o', 'LogLevel=ERROR',
         'ubuntu@' + instance.instance.public_ip_address, '--'] + command)


class Instance(object):
    def __init__(self, health):
        self.instance = ec2.Instance(id=health['Target']['Id'])
        self.instance.load()
        self.elb_health = health['TargetHealth']['State']
        self.service_status = {key: value for key, value in
                               (s.split("=", 1) for s in
                                exec_remote(self, ['sudo', 'systemctl', 'show', 'compiler-explorer']).split("\n") if
                                "=" in s)}

    def __str__(self):
        return '%s : %s' % (self.instance, self.health)

    @staticmethod
    def elb_instances(group_arn):
        return [Instance(health) for health in
                elb_client.describe_target_health(TargetGroupArn=group_arn)['TargetHealthDescriptions']]


def print_instances(instances, number=False):
    STATUS_FORMAT = '{: <16} {: <20} {: <10} {: <12} {: <10} {: <10}'
    if number:
        print '   ',
    print STATUS_FORMAT.format('Address', 'Instance Id', 'State', 'Type', 'ELB Status', 'Service Status')
    count = 0
    for inst in instances:
        if number:
            print '{: <3}'.format(count),
        count += 1
        print STATUS_FORMAT.format(
            inst.instance.public_ip_address,
            inst.instance.id,
            inst.instance.state['Name'],
            inst.instance.instance_type,
            inst.elb_health,
            inst.service_status['SubState'])


def status_cmd(args):
    print_instances(Instance.elb_instances(target_group_arn_for(args)), number=False)


def pick_instance(args):
    instances = Instance.elb_instances(target_group_arn_for(args))
    if len(instances) == 1:
        return instances[0]
    while True:
        print_instances(instances, number=True)
        inst = raw_input('Which instance? ')
        try:
            return instances[int(inst)]
        except:
            pass


def pick_instances(args):
    # TODO, maybe something in args to select only some?
    return Instance.elb_instances(target_group_arn_for(args))


def login_cmd(args):
    instance = pick_instance(args)
    run_remote(instance, [])


class Hash(object):
    def __init__(self, hash):
        self.hash = hash

    def __repr__(self):
        return self.hash

    def __str__(self):
        return self.hash[:6] + ".." + self.hash[-6:]


class Release(object):
    def __init__(self, version, branch, key, size, hash):
        self.version = version
        self.branch = branch
        self.key = key
        self.size = size
        self.hash = hash

    def __repr__(self):
        return 'Release({}, {}, {}, {}, {})'.format(self.version, self.branch, self.key, self.size, self.hash)


def sizeof_fmt(num, suffix='B'):
    for unit in ['', 'Ki', 'Mi', 'Gi', 'Ti', 'Pi', 'Ei', 'Zi']:
        if abs(num) < 1024.0:
            return "%3.1f%s%s" % (num, unit, suffix)
        num /= 1024.0
    return "%.1f%s%s" % (num, 'Yi', suffix)


def list_cmd(args):
    current = get_current_key(args)
    releases = get_releases()
    RELEASE_FORMAT = '{: <4} {: <10} {: <10} {: <10} {: <14}'
    print RELEASE_FORMAT.format('Live', 'Branch', 'Version', 'Size', 'Hash')
    for branch, releases in itertools.groupby(releases, lambda r: r.branch):
        for release in releases:
            print RELEASE_FORMAT.format(
                '**' if release.key == current else '',
                release.branch, release.version, sizeof_fmt(release.size), release.hash)


def branch_for_env(args):
    if args['env'] == 'prod':
        return 'release'
    elif args['env'] == 'beta':
        return 'beta'
    else:
        return 'master'


def version_key_for_env(env):
    return 'version/{}'.format(branch_for_env(env))


def get_current_key(args):
    try:
        o = s3_client.get_object(
            Bucket='compiler-explorer',
            Key=version_key_for_env(args)
        )
        return o['Body'].read().strip()
    except s3_client.exceptions.NoSuchKey:
        return None


def set_current_key(args, key):
    s3_key = version_key_for_env(args)
    print 'Setting {} to {}'.format(s3_key, key)
    s3_client.put_object(
        Bucket='compiler-explorer',
        Key=s3_key,
        Body=key,
        ACL='public-read'
    )


def current_cmd(args):
    current = get_current_key(args)
    if not current:
        print "No current version set"
        return
    releases = get_releases()
    for r in releases:
        if r.key == current:
            print r
            return
    print "Non-standard release with s3 key '{}'".format(current)


def get_releases():
    paginator = s3_client.get_paginator('list_objects_v2')
    PREFIX = 'dist/travis/'
    result_iterator = paginator.paginate(
        Bucket='compiler-explorer',
        Prefix=PREFIX
    )
    releases = []
    for result in result_iterator.search('[Contents][]'):
        key = result['Key']
        if not key.endswith(".tar.xz"):
            continue
        split_key = key.split('/')
        branch = split_key[-2]
        version = split_key[-1].split('.')[0]
        size = result['Size']
        info_key = "/".join(split_key[:-1]) + "/" + version + ".txt"
        o = s3_client.get_object(
            Bucket='compiler-explorer',
            Key=info_key
        )
        hash = o['Body'].read().strip()
        releases.append(Release(int(version), branch, key, size, Hash(hash)))
    return releases


def find_release(version):
    for r in get_releases():
        if r.version == version:
            return r
    return None


def restart_cmd(args):
    # TODO are you sure in prod
    for instance in pick_instances(args):
        run_remote(instance, ['sudo', 'systemctl', 'restart', 'compiler-explorer'])


def set_current_cmd(args):
    if args['raw']:
        to_set = args['version']
    else:
        release = find_release(int(args['version']))
        if not release:
            print "Unable to find version " + args.version
            sys.exit(1)
        print 'Found release {}'.format(release)
        to_set = release.key
    set_current_key(args, to_set)
    # TODO, ideally sync the versioned directory here, requires remote machine


if __name__ == '__main__':
    parser = ArgumentParser(description='Administrate Compiler Explorer instances')
    parser.add_argument('--env', choices=['prod', 'beta'], default='prod')
    subparsers = parser.add_subparsers(dest='command')
    list_parser = subparsers.add_parser('list')
    status_parser = subparsers.add_parser('status')
    login_parser = subparsers.add_parser('login')
    start_parser = subparsers.add_parser('start')
    stop_parser = subparsers.add_parser('stop')
    restart_parser = subparsers.add_parser('restart')
    current_parser = subparsers.add_parser('current')
    set_current = subparsers.add_parser('set_current')
    set_current.add_argument('version', help='version to set')
    set_current.add_argument('--raw', action='store_true', help='set a raw path for a version')
    kwargs = vars(parser.parse_args())
    globals()[kwargs.pop('command') + "_cmd"](kwargs)
